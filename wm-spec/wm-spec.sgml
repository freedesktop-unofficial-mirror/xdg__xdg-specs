<!doctype article PUBLIC "-//OASIS//DTD DocBook V4.0//EN" [
]>
<article id="index">
<articleinfo>
   <authorgroup>
      <corpauthor>
      <ulink url="http://www.freedesktop.org">X Desktop Group</ulink>
      </corpauthor>
      </authorgroup>
<title>Extended Window Manager Hints</title>
<date>10 March 2001</date>
</articleinfo>
<sect1>
	<title>Introduction</title>
	<sect2>
		<title>Version</title>
		<para>
This is DRAFT version 1.2 of the Extended Window Manager Hints (EWMH) spec,
updated October 17 2001.
		</para>
	</sect2>
	<sect2>
		<title>What is this spec?</title>
		<para>
This spec defines interactions between window managers, applications,
and the utilities that form part of a desktop environment.  It builds
on the ICCCM [2], which defines WM (window manager) interactions at a
lower level. The ICCCM does not provide ways to implement many
features that modern desktop users expect. The GNOME and KDE desktop
projects originally developed their own extensions to the ICCCM to
support these features; this spec replaces those custom extensions
with a standardized set of ICCCM additions that any desktop
environment can adopt.
		</para>
	</sect2>
	<sect2>
		<title>Language used in this specification</title>
		<para>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119.  
		</para>
		<para>
The key words "Window Manager" refer to a window manager which is adopting this
specification.  "Pager" refers to desktop utility applications, including
pagers and taskbars.  "Application" refers to other clients.  "Clients" refers
to Pagers + Applications ie. all X clients, except for the Window Manager.
		</para>
	</sect2>
	<sect2>
		<title>Prerequisites for adoption of this specification</title>
		<para>
Window Managers and Clients which aim to fulfil this specification MUST adhere 
to the ICCCM on which this specification builds. If this specification 
explicitly modifies the ICCCM Window Managers and Clients MUST fulfil these 
modifications.
		</para>
	</sect2>
</sect1>
<sect1>
<title>Non-ICCCM features</title>
<para>There is a number of window management features or behaviours which are 
not specified in the ICCCM, but are commonly met in modern Window Managers and Desktop Environments.</para>
<sect2>
<title>Additional States</title>
<para>The ICCCM allows Window Managers to implement additional window states, which will 
appear to clients as substates of NormalState and IconicState.  Two 
commonly met examples are Maximized and Shaded.  A Window Manager may implement these
as proper substates of NormalState and IconicState, or it may treat them 
as independent flags, allowing e.g. a maximized window to be iconified
and to re-appear as maximized upon de-iconification.</para>
<sect3>
<title>Maximization</title>
<para>Maximization is a very old feature of Window Managers.  There was even a ZoomedState
in early ICCCM drafts.  Maximizing a window should give it as much of the
screen area as possible (this may not be the full screen area, but only
a smaller 'workarea', since the Window Manager may have reserved certain areas for other 
windows).  A Window Manager is expected to remember the geometry of a maximized window 
and restore it upon de-maximization.  Modern Window Managers typically allow separate 
horizontal and vertical maximization.</para>
<para>With the introduction of the Xinerama extension in X11 R6.4, maximization
has become more involved.  Xinerama allows a screen to span multiple 
monitors in a freely configurable geometry.  In such a setting, maximizing 
a window would ideally not grow it to fill the whole screen, but only the 
monitor it is shown on.  There are of course borderline cases for windows 
crossing monitor boundaries, and 'real' maximization to the full screen may 
sometimes be useful.</para>
</sect3>
<sect3>
<title>Shading</title>
<para>Some Desktop Environments offer shading (also known as rollup) as an alternative to 
iconfication. A shaded window typically shows only the titlebar, the client 
window is hidden, thus shading is not useful for windows which are not 
decorated with a titlebar.</para>
</sect3>
</sect2>
<sect2>
<title>Modality</title>
<para>The Window Manager _TRANSIENT_FOR hint of the ICCCM allows clients to specify that a 
toplevel window may be closed before the client finishes.  A typical example 
of a transient window is a dialog.  Some dialogs can be open for a long time,  
while the user continues to work in the main window.  Other dialogs have to be 
closed before the user can continue to work in the main window.  This property 
is called modality.  While clients can implement modal windows in an ICCCM 
compliant way using the globally active input model, some Window Managers offer support 
for handling modality.
</para>
</sect2>
<sect2 id="largedesks">
<title>Large Desktops</title>
<para>The Window Manager may offer to arrange the managed windows on a desktop that is 
larger than the root window. The screen functions as a viewport on this large 
desktop. Different policies regarding the positioning of the viewport on the 
desktop can be implemented:  The Window Manager may only allow to change the viewport 
position in increments of the screen size (paging) or it may allow arbitrary 
positions (scrolling).</para>
<para>To fulfill the ICCCM principle that clients should behave the same
regardless wether a Window Manager is running or not, Window Managers which 
implement large desktops must interpret all client-provided geometries with 
respect to the current viewport.</para>
<sect3 id="largedesksimpl">
<title>Implementation note</title>
<para>There are two options for implementing a large desktop: The first is to 
keep the managed windows (or, if reparenting, their frames) as children
of the root window.  Moving the viewport is achieved by moving all managed
windows in the opposite direction.</para>
<para>The second alternative is to reparent all managed windows to a dedicated 
large window (somewhat inappropriately called a 'virtual root').  Moving 
the viewport is then achieved by moving the virtual root in the opposite 
direction.</para> 
<para>Both alternatives are completely ICCCM compliant, although the second one 
may be somewhat problematic for clients trying to figure out the Window Manager decorations
around their toplevel windows and for clients trying to draw background 
images on the root window.</para>
</sect3>
</sect2>
<sect2>
<title>Sticky windows</title>
<para>A Window Manager which implements a large desktop typically offers a way for the user 
to make certain windows 'stick to the glass', i.e. these windows will stay 
at the same position on the screen when the viewport is moved.</para>
</sect2>
<sect2>
<title>Virtual Desktops</title>
<para>Most X servers have only a single screen.  The Window Manager may virtualize this 
resource and offer multiple so-called 'virtual desktops', of which only one 
can be shown on the screen at a time.  There is some variation among the 
features of virtual desktop implementations.  There may be a fixed number 
of desktops, or new ones may be created dynamically.  The size of the desktops 
may be fixed or variable.  If the desktops are larger than the root window, 
their viewports (see <xref linkend="largedesks">) may be independent or forced to be at the same 
position.</para>
<para>A Window Manager which implements virtual desktops generally offers a way for the user
to move clients between desktops.  Clients may be allowed to occupy more than
one desktop simultaneously.</para>
<sect3>
<title>Implementation note</title>
<para>There are at least two options for implementing virtual desktops.  
The first is to use multiple virtual roots (see <xref linkend="largedesksimpl">) and change the current 
desktop by manipulating the stacking order of the virtual roots.  This is 
completely ICCCM compliant, but has the issues outlined in <xref linkend="largedesksimpl"></para>
<para>The second option is to keep all managed windows as children of the root 
window and unmap the frames of those which are not on the current desktop.
This puts the clients in an undefined ICCCM state, since they are unviewable,
but not iconic.  In practice, this seems to cause no problems and the ICCCM
compliant alternative to iconify all clients on non-current desktops (without
showing their icons) is clearly not acceptable.</para>
</sect3>
</sect2>
<sect2>
<title>Pagers</title>
<para>A pager offers a different UI for window management tasks.  It shows a 
miniature view of the desktop(s) representing managed windows by small 
rectangles and allows the user to initiate various Window Manager actions by manipulating 
these representations.  Typically offered actions are activation (see <xref linkend="activation">), 
moving, restacking, iconification, maximization and closing.  On a large 
desktop, the pager may offer a way to move the viewport.  On virtual desktops, 
the pager may offer ways to move windows between desktops and to change the 
current desktop.</para>
</sect2>
<sect2>
<title>Taskbars</title>
<para>A taskbar offers another UI for window management tasks.  It typically 
represents client windows as a list of buttons labelled with the window
titles and possibly icons.  Pressing a button initiates a Window Manager action on the
represented window, typical actions being activation and iconification. 
In environments with a taskbar, icons are often considered inappropriate,
since the iconified windows are already represented in the taskbar.</para>
</sect2>
<sect2 id="activation">
<title>Activation</title>
<para>In the X world, activating a window means to give it the input focus.
This may not be possible if the window is unmapped, because it is on a
different desktop.  Thus, activating a window may involve additional steps
like moving it to the current desktop (or changing to the desktop the window
is on), deiconifying it or raising it.</para>
</sect2>
<sect2>
<title>Animated iconification</title>
<para>Some Window Managers display some form of animation when (de-)iconifying a window.
This may be a line drawing connecting the corners of the window with
the corners of the icon or the window may be opaquely moved and resized 
on some trajectory joining the window location and the icon location.</para>
</sect2>
<sect2>
<title>Window-in-window MDI</title>
<para>Window-in-window MDI is a multiple document interface known from MS
Windows platforms. Programs employing it have a single top-level window
which contains a workspace which contains the subwindows for the open
documents. These subwindows are decorated with Window Manager frames and can be
manipulated within their parent window just like ordinary top-level
windows on the root window.</para>
</sect2>
<sect2>
<title>Scope of this spec</title>
<para>This spec tries to address the following issues:</para>
<itemizedlist>
<listitem><para>Allow clients to influence their initial state with respect 
to maximization, shading, stickyness, desktop.</para></listitem>
<listitem><para>Improve the Window Managers ability to vary window 
decorations by allowing clients to hint the Window Manager about the type 
of their windows.</para></listitem>
<listitem><para>Enable pagers and taskbars to be implemented as separate 
clients and allow them to work with any compliant Window Manager.</para></listitem>
</itemizedlist>
<para>This spec doesn't cover any of the following:</para>
<itemizedlist>
<listitem><para>Other IPC mechanisms like ICE or Corba.</para></listitem>
<listitem><para>Window Manager configuration.</para></listitem>
<listitem><para>Window Manager documentation.</para></listitem>
<listitem><para>Geometry between desktops.</para></listitem>
<listitem><para>Clients appearing on a proper subset of desktops.</para></listitem>
<listitem><para>Window-in-window MDI.</para></listitem>
</itemizedlist>
<para>The Window Manager is supposed to be in charge of window management 
policy, so that there is consistent behaviour on the user's screen no matter 
who wrote the clients.</para>
<para>The spec offers a lot of external control about Window Manager actions.  
This is intended mainly to allow pagers, taskbars and similar Window Manager 
UIs to be implemented as separate clients.  "Ordinary" clients shouldn't use 
these except maybe in response to a direct user request (i.e. setting a 
config option to start maximized or specifying a -desk n cmdline 
argument).</para>
</sect2>
</sect1>
<sect1>
	<title>Root Window Properties (+Related Messages)</title>
	<para>
Whenever this spec speaks about <quote>sending a message to the root 
window</quote>, it is understood that the client is supposed to create 
a ClientMessage event with the specified contents and send it by using 
a SendEvent request with the following arguments:
	<programlisting><![CDATA[
destination     root
propagate       False
event-mask      (SubstructureNotify|SubstructureRedirect)
event           the specified ClientMessage
]]></programlisting>
	</para>
	<sect2><title>_NET_SUPPORTED</title>
	<programlisting><![CDATA[
_NET_SUPPORTED, ATOM[]/32
]]></programlisting>
	<para>
This property MUST be set by the Window Manager to indicate which hints it
supports.  For example: considering _NET_WM_STATE 
both this atom and all supported states e.g. _NET_WM_STATE_MODAL, 
_NET_WM_STATE_STICKY, would be listed. This assumes that backwards 
incompatible changes will not be made to the hints (without being renamed). 
	</para>
	</sect2><sect2><title>_NET_CLIENT_LIST</title>
	<programlisting><![CDATA[
_NET_CLIENT_LIST, WINDOW[]/32
_NET_CLIENT_LIST_STACKING, WINDOW[]/32
]]></programlisting>
	<para>
These arrays contain all X Windows managed by the Window Manager.  
_NET_CLIENT_LIST has initial mapping order, starting with the oldest window. 
_NET_CLIENT_LIST_STACKING has bottom-to-top stacking order.  These properties
SHOULD be set and updated by the Window Manager.
	</para>
	</sect2>
	<sect2>
		<title>_NET_NUMBER_OF_DESKTOPS</title>
	<programlisting><![CDATA[
_NET_NUMBER_OF_DESKTOPS, CARDINAL/32
]]></programlisting>
	<para>
This property SHOULD be set and updated by the Window Manager to indicate the
number of virtual desktops. 
	</para>
	<para>
A Pager can request change in the desktops number by sending a _NET_NUMBER_OF_DESKTOPS message to the root window:
	</para>
	<programlisting><![CDATA[
_NET_NUMBER_OF_DESKTOPS
  message_type = _NET_NUMBER_OF_DESKTOPS
  format = 32
  data.l[0] = new_number_of_desktops
]]></programlisting>
	<para>
The Window Manager is free to honor or reject this request. If request is honored _NET_NUMBER_OF_DESKTOPS MUST be set to the new number of desktops, _NET_VIRTUAL_ROOTS MUST be set to store the new number of desktop virtual root window IDs and _NET_DESKTOP_VIEWPORT and _NET_WORKAREA must also be changed accordingly. The _NET_DESKTOP_NAMES property MAY remain unchanged.
	</para>
	<para> 
If the number of desktops is shrinking and _NET_CURRENT_DESKTOP is out of the new range of available desktops, then this MUST be set to the last available desktop from the new set. If number of desktops is shrinking then clients that are still present on desktops, that are out of the new range, MUST be moved to the very last desktop from the new set. For these _NET_WM_DESKTOP MUST be updated.
	</para>
	</sect2>
	<sect2>
		<title>_NET_DESKTOP_GEOMETRY</title>
		<programlisting><![CDATA[
_NET_DESKTOP_GEOMETRY width, height, CARDINAL[2]/32
]]></programlisting>
		<para>
Array of two cardinals that defines the common size of all desktops. 
This property SHOULD be set by the Window Manager. 
		</para>
		<para>
A Pager can request a change in  the desktop geometry by sending a _NET_DESKTOP_GEOMETRY client
message to the root window:
		</para>
	<programlisting><![CDATA[
_NET_DESKTOP_GEOMETRY
  message_type = _NET_DESKTOP_GEOMETRY 
  format = 32
  data.l[0] = new_width
  data.l[1] = new_height
]]></programlisting> 
		<para>
The Window Manager MAY choose to ignore this message, in which case _NET_DESKTOP_GEOMETRY property will remain unchanged.
		</para>
	</sect2>
	<sect2>
		<title>_NET_DESKTOP_VIEWPORT</title>
	<programlisting><![CDATA[
_NET_DESKTOP_VIEWPORT x, y, CARDINAL[][2]/32
]]></programlisting>
	<para>
Array of pairs of cardinals that define the top left corner of each desktops 
viewport.  For window managers that don't support large desktops, this MUST 
always be set to (0,0).  
	</para>	
	<para>
A Pager can request to change the viewport for the current desktop by sending a
_NET_DESKTOP_VIEWPORT client message to the root window:
	</para>
	<programlisting><![CDATA[
_NET_DESKTOP_VIEWPORT
  message_type = _NET_DESKTOP_VIEWPORT
  format = 32
  data.l[0] = new_vx
  data.l[1] = new_vy
]]></programlisting> 
		<para>
The Window Manager MAY choose to ignore this message, in which case _NET_DESKTOP_VIEWPORT property will remain unchanged.
		</para>
	</sect2><sect2><title>_NET_CURRENT_DESKTOP</title>
	<programlisting><![CDATA[
_NET_CURRENT_DESKTOP desktop, CARDINAL/32
]]></programlisting>
	<para>
The index of the current desktop. This is always an integer between 0 and 
_NET_NUMBER_OF_DESKTOPS - 1. This MUST be set and updated by the Window 
Manager  If a Pager wants to switch to another virtual desktop, it MUST send 
a _NET_CURRENT_DESKTOP client message to the root window:
	</para>
	<programlisting><![CDATA[
_NET_CURRENT_DESKTOP
  message_type = _NET_CURRENT_DESKTOP 
  format = 32
  data.l[0] = new_index
]]></programlisting>
	</sect2><sect2><title>_NET_DESKTOP_NAMES</title>
	<programlisting><![CDATA[
_NET_DESKTOP_NAMES, UTF8_STRING[]
]]></programlisting>
	<para>
The names of all virtual desktops. This is a list of NULL-terminated strings in UTF-8 [1] encoding. This property MAY be changed by a Pager or the Window Manager at any time.
	</para>
<para>
Note: The number of names could be different from _NET_NUMBER_OF_DESKTOPS.
If it is less than _NET_NUMBER_OF_DESKTOPS - then the desktops with high
numbers are unnamed. If it is larger than _NET_NUMBER_OF_DESKTOPS, then the 
excess names outside of the _NET_NUMBER_OF_DESKTOPS are considered to be
reserved in case number of desktops is increased.
</para>
<para>
Rationale: The name is not a necessary attribute of a virtual desktop. Thus 
the availability or unavailability of names has no impact on virtual desktop
functionality. Since names are set by users and users are likely to preset 
names for a fixed number of desktops, it doesn't make sense to shrink or grow 
this list when the number of available desktops changes.
</para>
	</sect2><sect2><title>_NET_ACTIVE_WINDOW</title>
	<programlisting><![CDATA[
_NET_ACTIVE_WINDOW, WINDOW/32
]]></programlisting>
	<para>
The window ID of the currently active window or None if no window has the focus.
This is a read-only property set by the
window manager.  If a client (for example, a taskbar) wants to activate
another window, it MUST send a _NET_ACTIVE_WINDOW client message to the root
window: 
	</para>
	<programlisting><![CDATA[
_NET_ACTIVE_WINDOW
  window  = window to activate
  message_type = _NET_ACTIVE_WINDOW
  format = 32
  data.l[0] = 0 /* may be used later */
]]></programlisting>
	</sect2><sect2><title>_NET_WORKAREA</title>
	<programlisting><![CDATA[
_NET_WORKAREA, x, y, width, height CARDINAL[][4]/32
]]>
	</programlisting>
	<para>
This property MUST be set by WM upon calculating the work area for 
each desktop.  Contains a geometry for each desktop.  These geometries are 
specified relative to the viewport on each desktop and specify an area that is
completely contained within the viewport.
 Work area SHOULD be used by desktop applications to place desktop icons appropriately.
	</para>
	<para>
	The window manager SHOULD calculate this space by taking the current page minus space occupied by dock and panel windows, as indicated by the <link linkend="NETWMSTRUT">_NET_WM_STRUT</link> property set on client windows.
	</para>
	</sect2>
	<sect2>
	<title>_NET_SUPPORTING_WM_CHECK</title>
	<programlisting><![CDATA[
_NET_SUPPORTING_WM_CHECK, WINDOW/32
]]></programlisting>
	<para>
The Window Manager MUST set this property on the root window to be the ID of a
	child window created by the WM, to indicate that a compliant WM is
	active.  The child window MUST also have the _NET_SUPPORTING_WM_CHECK
	property set to the ID of the child window. The child window MUST also
	have the _NET_WM_NAME property set to the name of the Window Manager.
	</para>
	<para>
Rationale:  The child window is used to distinguish an active window manager 
 from a stale _NET_SUPPORTING_WM_CHECK 
 property that happens to point to another window. If the
 _NET_SUPPORTING_WM_CHECK window on the client window is missing
 or not properly set, clients SHOULD assume that no conforming
 window manager is present.
	</para>
	</sect2>
	<sect2>
	<title>_NET_VIRTUAL_ROOTS</title>
	<programlisting><![CDATA[
_NET_VIRTUAL_ROOTS, WINDOW[]/32
]]></programlisting>
	<para>
To implement virtual desktops, some window managers reparent client windows to 
a child of the root window.  Window managers using this technique MUST set 
this property to a list of IDs for windows that are acting as virtual root 
windows.  This property allows background setting programs to work with 
virtual roots and allows clients to figure out the WM frame windows of their 
windows.
	</para>
	</sect2>
	</sect1>
	<sect1>
	<title>Other Root Window Messages</title>
	<sect2><title>_NET_CLOSE_WINDOW</title>
	<programlisting><![CDATA[
_NET_CLOSE_WINDOW
]]></programlisting>
	<para>
	Pagers wanting to close a window MUST send a _NET_CLOSE_WINDOW client
	message request to the root window:
	</para>
<programlisting><![CDATA[
_NET_CLOSE_WINDOW
  window = window to close
  message_type = _NET_CLOSE_WINDOW
  format = 32
  data.l[0] = 0 /* may be used later */
]]></programlisting>
	<para>
The Window Manager MUST then attempt to close the window specified.
	</para>
	<para>
	Rationale: A window manager might be more clever than the usual method (send WM_DELETE message if the protocol is selected, XKillClient otherwise).  It might introduce a timeout, for example.  Instead of duplicating the code, the Window Manager can easily do the job.
	</para>
	</sect2><sect2><title>_NET_WM_MOVERESIZE</title>
	<programlisting><![CDATA[
_NET_WM_MOVERESIZE
  window = window to be moved or resized
  message_type = _NET_WM_MOVERESIZE
  format = 32
  data.l[0] = x_root 
  data.l[1] = y_root
  data.l[2] = direction
]]></programlisting>
	<para>
	This message allows an application to initiate window movement or resizing.  This allows the application to define its own move and size "grips", whilst letting the window manager control the actual move/resize.  This means that all moves / resizes can happen in a consistent manner as defined by the WM.
	</para>
	<para>
	When sending this message, x_root and y_root MUST indicate the position of the mouse click with respect to the root window and direction MUST indicate whether this is a move or resize event, and if it is a resize event, which edges of the window the size grip applies to.
	</para>
	<programlisting><![CDATA[
#define _NET_WM_MOVERESIZE_SIZE_TOPLEFT      0
#define _NET_WM_MOVERESIZE_SIZE_TOP          1
#define _NET_WM_MOVERESIZE_SIZE_TOPRIGHT     2
#define _NET_WM_MOVERESIZE_SIZE_RIGHT        3
#define _NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT  4
#define _NET_WM_MOVERESIZE_SIZE_BOTTOM       5
#define _NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT   6
#define _NET_WM_MOVERESIZE_SIZE_LEFT         7
#define _NET_WM_MOVERESIZE_MOVE              8   /* Movement only */
]]></programlisting>
	<para>
	The client MUST release all grabs on Pointer events, prior to sending such message.
	</para>
	</sect2>
	</sect1>	
	<sect1>
	<title>Application Window Properties</title>
	<sect2><title>_NET_WM_NAME</title>
	<programlisting><![CDATA[
_NET_WM_NAME, UTF8_STRING
]]></programlisting>
	<para>
The Client SHOULD set this to the title of the window in UTF-8 encoding.  If
set, the Window Manager should use this in preference to WM_NAME.
	</para>
	</sect2>

	<sect2><title>_NET_WM_VISIBLE_NAME</title>
	<programlisting><![CDATA[
_NET_WM_VISIBLE_NAME, UTF8_STRING
]]></programlisting>
	<para>
If the Window Manager displays a window name other than _NET_WM_NAME the Window Manager MUST set this to the title displayed in UTF-8 encoding.
	</para>
        <para>
Rationale: For window managers that display a title different from the _NET_WM_NAME or WM_NAME of the window (i.e. xterm <1>, xterm <2>, ... is shown, but _NET_WM_NAME / WM_NAME is still xterm for each window). This property allows taskbars / pagers to display the same title as the window manager.
        </para>
	</sect2>

	<sect2><title>_NET_WM_ICON_NAME</title>
	<programlisting><![CDATA[
_NET_WM_ICON_NAME, UTF8_STRING
]]></programlisting>
	<para>
The Client SHOULD set this to the title of the icon for this window in UTF-8 
encoding.  If set, the Window Manager should use this in preference to 
WM_ICON_NAME.
	</para>
	</sect2>

	<sect2><title>_NET_WM_VISIBLE_ICON_NAME</title>
	<programlisting><![CDATA[
_NET_WM_VISIBLE_ICON_NAME, UTF8_STRING
]]></programlisting>
	<para>
If the Window Manager displays an icon name other than _NET_WM_ICON_NAME 
the Window Manager MUST set this to the title displayed in UTF-8 encoding.
	</para>
	</sect2>

	<sect2><title>_NET_WM_DESKTOP</title>
	<programlisting><![CDATA[
_NET_WM_DESKTOP <desktop>, CARDINAL/32
]]></programlisting>
	<para>
Cardinal to determine the desktop the window is in (or wants to be) starting
with 0 for the first desktop.  A Client MAY choose not to set this property,
in which case the Window Manager SHOULD place as it wishes.  0xFFFFFFFF
indicates that the window SHOULD appear on all desktops/workspaces.  
	</para>
	<para>
The Window Manager should honor _NET_WM_DESKTOP whenever a withdrawn window
requests to be mapped.  
	</para>
	<para>
A Client can request a change of desktop for a non-withdrawn window by sending
a _NET_WM_DESKTOP client message to the root window:
	</para>
	<programlisting><![CDATA[
_NET_WM_DESKTOP
  window  = the respective client window
  message_type = _NET_WM_DESKTOP
  format = 32
  data.l[0] = new_desktop
]]></programlisting>
	<para>
	The Window Manager MUST keep this property updated on all windows.
	</para>
	</sect2><sect2><title>_NET_WM_WINDOW_TYPE</title>
	<programlisting><![CDATA[
_NET_WM_WINDOW_TYPE, ATOM[]/32
]]></programlisting>
	<para>
This SHOULD be set by the Client before mapping, to a list of atoms indicating
the functional type of the window.  This property SHOULD be used by the window
manager in determining the decoration, stacking position and other behaviour
of the window.  The Client SHOULD specify window types in order of preference
(the first being most preferable), but MUST include at least one of the basic
window type atoms from the list below.  This is to allow for extension of the
list of types, whilst providing default behaviour for window managers that do
not recognise the extensions.  
	</para>
	<para>
Rationale:  This hint is intend to replace the MOTIF hints.  One of the
objections to the MOTIF hints is that they are a purely visual description of
the window decoration.  By describing the function of the window, the window
manager can apply consistent decoration and behaviour to windows of the same
type.  Possible examples of behaviour include keeping dock/panels on top or
allowing pinnable menus / toolbars to only be hidden when another window has
focus (NextStep style).  
	</para>
	<programlisting><![CDATA[
_NET_WM_WINDOW_TYPE_DESKTOP, ATOM
_NET_WM_WINDOW_TYPE_DOCK, ATOM
_NET_WM_WINDOW_TYPE_TOOLBAR, ATOM
_NET_WM_WINDOW_TYPE_MENU, ATOM
_NET_WM_WINDOW_TYPE_UTILITY, ATOM
_NET_WM_WINDOW_TYPE_SPLASH, ATOM
_NET_WM_WINDOW_TYPE_DIALOG, ATOM
_NET_WM_WINDOW_TYPE_NORMAL, ATOM
]]></programlisting>	
	<para>
_NET_WM_WINDOW_TYPE_DESKTOP indicates a desktop feature.  This can include a
single window containing desktop icons with the same dimensions as the screen,
allowing the desktop environment to have full control of the desktop, without
the need for proxying root window clicks.  
	</para>
	<para>
_NET_WM_WINDOW_TYPE_DOCK indicates a dock or panel feature.  Typically a
window manager would keep such windows on top of all other windows.  
	</para>
	<para>
_NET_WM_WINDOW_TYPE_TOOLBAR and _NET_WM_WINDOW_TYPE_MENU indicate toolbar and
pinnable menu windows, respectively (i.e. toolbars and menus "torn off" from 
the main application). Windows of this type may set the WM_TRANSIENT_FOR 
hint indicating the main application window.
	</para>
	<para>
_NET_WM_WINDOW_TYPE_UTILITY indicates a small persistent utility window, such as
a palette or toolbox. It is distinct from type TOOLBAR because it does not
correspond to a toolbar torn off from the main application. It's distinct from
type DIALOG because it isn't a transient dialog, the user will probably keep it
open while they're working. Windows of this type may set the WM_TRANSIENT_FOR
hint indicating the main application window.
	</para>
	<para>
_NET_WM_WINDOW_TYPE_SPLASH indicates that the window is a splash screen
displayed as an application is starting up.
	</para>
	<para>
_NET_WM_WINDOW_TYPE_DIALOG indicates that this is a dialog window.  If
_NET_WM_WINDOW_TYPE is not set, then windows with WM_TRANSIENT_FOR set MUST
be taken as this type.  
	</para>
	<para>
_NET_WM_WINDOW_TYPE_NORMAL indicates that this is a normal, top-level window.
Windows with neither _NET_WM_WINDOW_TYPE nor WM_TRANSIENT_FOR are set MUST
be taken as this type.
	</para>
	</sect2>
	<sect2>
		<title>_NET_WM_STATE</title>
		<programlisting><![CDATA[
_NET_WM_STATE, ATOM[]
]]></programlisting>
		<para>
A list of hints describing the window state. Atoms present in the list MUST be
considered set, atoms not present in the list MUST be considered not set. The
Window Manager SHOULD honor
_NET_WM_STATE whenever a withdrawn window requests to be mapped.  A Client
wishing to change the state of a window MUST send a _NET_WM_STATE client
message to the root window (see below).  The Window Manager MUST keep this
property updated to reflect the current state of the window.
		</para>
		<para>
Possible atoms are:
		</para>
	<programlisting><![CDATA[
_NET_WM_STATE_MODAL, ATOM
_NET_WM_STATE_STICKY, ATOM
_NET_WM_STATE_MAXIMIZED_VERT, ATOM
_NET_WM_STATE_MAXIMIZED_HORZ, ATOM
_NET_WM_STATE_SHADED, ATOM
_NET_WM_STATE_SKIP_TASKBAR, ATOM
_NET_WM_STATE_SKIP_PAGER, ATOM
_NET_WM_STATE_FULLSCREEN, ATOM
]]></programlisting>
      <para>
An implementation MAY add new atoms to this list. Implementations
without extensions MUST ignore any unknown atoms, effectively removing
them from the list. These extension atoms MUST NOT start with the prefix
_NET. 
      </para>
	<para>
_NET_WM_STATE_MODAL indicates that this is a modal dialog box.  The
WM_TRANSIENT_FOR hint MUST be set to indicate which window the dialog is a
modal for, or set to the root window if the dialog is a modal for its window
group.
	</para>
	<para>
_NET_WM_STATE_STICKY indicates that the Window Manager SHOULD keep the
window's position fixed on the screen, even when the virtual desktop scrolls.
	</para>
	<para>
_NET_WM_STATE_MAXIMIZED_{VERT,HORZ} indicates that the window is
{vertically,horizontally} maximised.
	</para>
	<para>
_NET_WM_STATE_SHADED indicates that the window is shaded.
	</para>
	<para>
_NET_WM_STATE_SKIP_TASKBAR indicates that the window should not be included on a
taskbar.
	</para>
	<para>
_NET_WM_STATE_SKIP_PAGER indicates that the window should not be included on a
pager.
	</para>
	<para>
_NET_WM_STATE_FULLSCREEN indicates that the window should fill the entire screen
and have no window decorations. For example, a presentation program would use
this hint.
	</para>
	<para>
To change the state of a mapped window, a Client MUST send a _NET_WM_STATE
client message to the root window  (window is the respective window, type
_NET_WM_STATE, format 32, l[0]=&lt;the action, as listed below&gt;,
l[1]=&lt;First property to alter&gt;, l[2]=&lt;Second property to alter&gt;).
This message allows two properties to be changed simultaneously, specifically
to allow both horizontal and vertical maximisation to be altered together.
l[2] MUST be set to zero if only one property is to be changed. l[0], the
action, MUST be one of:
	</para>
	<programlisting><![CDATA[
_NET_WM_STATE_REMOVE        0    /* remove/unset property */
_NET_WM_STATE_ADD           1    /* add/set property */
_NET_WM_STATE_TOGGLE        2    /* toggle property  */
]]></programlisting>
      <para>
	See also the implementation notes on <link linkend="URGENCY">urgency</link> and <link linkend="NORESIZE">fixed size windows</link>.
	</para>
	</sect2>

	<sect2>
		<title>_NET_WM_ALLOWED_ACTIONS</title>
		<programlisting><![CDATA[
_NET_WM_ALLOWED_ACTIONS, ATOM[]
]]></programlisting>
		<para>
A list of atoms indicating user operations that the window manager supports for
this window. Atoms present in the list indicate allowed actions, atoms not
present in the list indicate actions that are not supported for this window.
The window manager MUST keep this property updated to reflect the 
actions which are currently "active" or "sensitive" for a window.
Taskbars, pagers, and other tools use _NET_WM_ALLOWED_ACTIONS to 
decide which actions should be made available to the user.
		</para>
		<para>
Possible atoms are:
		</para>
	<programlisting><![CDATA[
_NET_WM_ACTION_MOVE, ATOM
_NET_WM_ACTION_RESIZE, ATOM
_NET_WM_ACTION_SHADE, ATOM
_NET_WM_ACTION_STICK, ATOM
_NET_WM_ACTION_MAXIMIZE_HORZ, ATOM
_NET_WM_ACTION_MAXIMIZE_VERT, ATOM
_NET_WM_ACTION_CHANGE_DESKTOP, ATOM
_NET_WM_ACTION_CLOSE, ATOM
]]></programlisting>
      <para>
An implementation MAY add new atoms to this list. Implementations
without extensions MUST ignore any unknown atoms, effectively removing
them from the list. These extension atoms MUST NOT start with the prefix
_NET.
      </para>
      <para>
Note that the actions listed here are those that the <emphasis>window
manager</emphasis> will honor for this window. The operations must still be
requested through the normal mechanisms outlined in this specification. For
example, _NET_WM_ACTION_CLOSE does not mean that clients can send a
WM_DELETE_WINDOW message to this window; it means that clients can use a
_NET_CLOSE_WINDOW message to ask the window manager to do so.
       </para>
       <para>
Window managers SHOULD ignore the value of _NET_WM_ALLOWED_ACTIONS when they 
initially manage a window. This value may be left over from a previous window 
manager with different policies.
      </para>
	<para>
_NET_WM_ACTION_MOVE indicates that the window may be moved around the screen.
	</para>
	<para>
_NET_WM_ACTION_RESIZE indicates that the window may be resized.
(Implementation note: window managers can identify a non-resizable 
window because its minimum and maximum size in WM_NORMAL_HINTS will be the same.)
	</para>
	<para>
_NET_WM_ACTION_SHADE indicates that the window may be shaded.
	</para>
	<para>
_NET_WM_ACTION_STICK indicates that the window may have its sticky state 
toggled (as for _NET_WM_STATE_STICKY). Note that this state has to do with 
viewports, not desktops.
	</para>
	<para>
_NET_WM_ACTION_MAXIMIZE_HORZ indicates that the window may be maximized horizontally.
	</para>
	<para>
_NET_WM_ACTION_MAXIMIZE_VERT indicates that the window may be maximized vertically.
	</para>
	<para>
_NET_WM_ACTION_CHANGE_DESKTOP indicates that the window may be moved between desktops.
	</para>
	<para>
_NET_WM_ACTION_CLOSE indicates that the window may be closed (i.e. a WM_DELETE_WINDOW 
message may be sent).
	</para>
</sect2>

<sect2><title>_NET_WM_STRUT</title>
	<programlisting id="NETWMSTRUT"><![CDATA[
_NET_WM_STRUT, left, right, top, bottom, CARDINAL[4]/32
]]></programlisting>
	<para>
This property MUST be set by the Client if the window is to reserve space at
the edge of the screen.  The property contains a 4 cardinals specifying the
width of the reserved area at each border of the screen.  
The order of the borders is left, right, top, bottom.
The client MAY change this property anytime, therefore the Window Manager MUST
watch out for property notify events.  
	</para>
	<para>
The purpose of struts is to reserve space at the borders of the desktop.  This
is very useful for a docking area, a taskbar or a panel, for instance.  The
window manager should know about this reserved space in order to be able to
preserve the space. Also maximized windows should not cover that reserved
space.
	</para>
	<para>
Rationale: A simple "do not cover" hint is not enough for dealing with e.g.
auto-hide panels. 
	</para>
	<para>
Notes: An auto-hide panel SHOULD set the strut to be its minimum, hidden size.
A "corner" panel that does not extend for the full length of a screen border
SHOULD only set one strut.
	</para>
	</sect2><sect2><title>_NET_WM_ICON_GEOMETRY</title>
<programlisting><![CDATA[
_NET_WM_ICON_GEOMETRY, x, y, width, height, CARDINAL[4]/32
]]></programlisting>
	<para>
This optional property MAY be set by standalone tools like a taskbar or an 
iconbox.  It specifies the geometry of a possible icon in case the window is iconified.
	</para>
	<para>
Rationale: This makes it possible for a window manager to display a nice
animation like morphing the window into its icon.
	</para>
	</sect2>
	<sect2>
		<title>_NET_WM_ICON</title>
		<programlisting><![CDATA[
_NET_WM_ICON CARDINAL[][2+n]/32
]]></programlisting>
		<para>
This is an array of possible icons for the client.  This specification does
not stipulate what size these icons should be, but individual desktop
environments or toolkits may do so.  The Window Manager MAY scale any of these
icons to an appropriate size.
		</para>
		<para>
This is an array of 32bit packed CARDINAL ARGB with high byte being A, low
byte being B.  First two cardinals are width, height.  Data is in rows, left to
right and top to bottom.
		</para>
	</sect2>
	<sect2>
		<title>_NET_WM_PID</title>
	<programlisting><![CDATA[
_NET_WM_PID CARDINAL/32
]]></programlisting>
		<para>
If set, this property MUST contain the process ID of the client owning this
window.  This MAY be used by the Window Manager to kill windows which do not
respond to the _NET_WM_PING protocol.
		</para>
	<para>
If _NET_WM_PID is set, the ICCCM-specified property WM_CLIENT_MACHINE
MUST also be set.  While the ICCCM only requests that WM_CLIENT_MACHINE is set
<quote> to a string that forms the name of the machine running the client as
seen from the machine running the server</quote> conformance to this
specification requires that WM_CLIENT_MACHINE be set to the fully-qualified domain 
name of the client's host.
	</para>
	<para>
See also the implementation notes on <link linkend="KILLINGWINDOWS">killing hung processes</link>.
	</para>
	</sect2>
	<sect2><title>_NET_WM_HANDLED_ICONS</title>
	<programlisting><![CDATA[
_NET_WM_HANDLED_ICONS
]]></programlisting>
	<para>
This property can be set by clients to indicate that the Window Manager need
not provide icons for iconified windows, for example if the client is a taskbar
and provides buttons for iconified windows.
	</para>
	</sect2>
</sect1>
<sect1>
	<title>Window Manager Protocols</title>
	<sect2>
		<title>_NET_WM_PING</title>
		<para>
This protocol allows the Window Manager to determine if the Client is still
processing X events.  This can be used by the Window Manager to determine if a
window which fails to close after being sent WM_DELETE_WINDOW has stopped
responding, or has stalled for some other reason, such as waiting for user
confirmation.  A Client SHOULD indicate that it is willing to participate in
this protocol by listing _NET_WM_PING in the WM_PROTOCOLS property of the
client window.
		</para>
		<para>
A Window Manager can use this protocol at any time by sending a client message
as follows:
		</para>
		<programlisting><![CDATA[
type = ClientMessage
window = the respective client window
message_type = WM_PROTOCOLS
format = 32
data.l[0] = _NET_WM_PING
data.l[1] = timestamp
]]></programlisting>
		<para>
A participating Client receiving this message MUST send it back to the root
window immediately, by setting window = root, and calling XSendEvent.  The
Client MUST NOT alter the timestamp, as this can be used by the Window Manager
to uniquely identify the ping.
		</para>
		<para>
The Window Manager MAY kill the Client (using _NET_WM_PID) if it fails to
respond to this protocol within a reasonable time.
		</para>
		<para>
See also the implementation notes on <link linkend="KILLINGWINDOWS">killing hung processes</link>.
		</para>
	</sect2>
</sect1>
<sect1>
	<title>Implementation notes</title>
	<sect2>
		<title>Desktop/workspace model</title>
		<para>
This spec assumes a desktop model that consists of one or more completely
independent desktops which may or may not be larger than the screen area.
When a desktop is larger than the screen it is left to the window manager if
it will implement scrolling or paging.
		</para>
	</sect2>
	<sect2>
		<title>File Manager desktop</title>
		<para>
This spec suggests implementing the file manager desktop by mapping a
desktop-sized window (no shape) to all desktops, with
_NET_WM_WINDOW_TYPE_DESKTOP.  This makes the desktop focusable and greatly
simplifies implementation of the file manager.  It is also faster than
managing lots of small shaped windows. The file manager draws the background
on this window.  There should be a root property with a window handle for use
in applications that want to draw the background (xearth).
		</para>
	</sect2>
	<sect2>
		<title>Implementing enhanced support for application transient windows</title>
		<para>
If the WM_TRANSIENT_FOR property is set to None or Root window, the window
should be treated as a transient for all other windows in the same group.  It
has been noted that this is a slight ICCCM violation, but as this behaviour is
pretty standard for many toolkits and window managers, and is extremely
unlikely to break anything, it seems reasonable to document it as standard.
		</para>
	</sect2>
	<sect2 id="URGENCY">
		<title>Urgency</title>
		<para>
	Dialog boxes should indicate their urgency level (information or warning) using the urgency bit in the WM_HINTS.flags property, as defined in the ICCCM.
		</para>
	</sect2>
	<sect2 id="NORESIZE">
	<title>Fixed size windows</title>
	<para>
	Windows can indicate that they are non-resizable by setting minheight = maxheight and minwidth = maxwidth in the ICCCM WM_NORMAL_HINTS property.  The Window Manager MAY decorate such windows differently.
	</para>
	</sect2>
	<sect2>
	<title>Pagers and Taskbars</title>
	<para>
	This specification attempts to make reasonable provisions for WM independent pagers and taskbars.  Window Managers that require / desire additional functionality beyond what can be achieved using the mechanisms set out in this specification may choose to implement their own pagers, which communicates with the Window Manager using further, WM-specific hints, or some other means.
	</para>
	</sect2>
	<sect2>
	<title>Window Movement</title>
	<para>
Window manager implementors should refer to the ICCCM for definitive
specifications of how to handle MapRequest and ConfigureRequest events.
However, since these aspects of the ICCCM are easily misread, this
document offers the following clarifications:
	</para>
	<itemizedlist>
		<listitem><para>
Window managers MUST honour the win_gravity field of WM_NORMAL_HINTS
   for both MapRequest _and_ ConfigureRequest events [1]
		</para></listitem>
		<listitem><para>
Applications are free to change their win_gravity setting at any time
		</para>
		<para>
If application changes its gravity then Window manager should adjust the
reference point, so that client window will not move as the result.
For example if client's gravity was NorthWestGravity and reference point
was
at the top-left corner of the frame window, then after change of gravity to
the SouthEast reference point should be adjusted to point to the
lower-right
corner of the frame.
		</para></listitem>
		<listitem><para>
When generating synthetic ConfigureNotify events, the position given
   MUST be the top-left corner of the client window in relation to the
   origin of the root window (i.e., ignoring win_gravity) [2]
		</para></listitem>
		<listitem><para>
XMoveWindow(w,x,y) behaviour depends on the window gravity. Upon receiving a
request from client application the Window Manager calculates a new reference
point, based on the client window's own size, border width and gravity. For given client
window dimentions (width, height) and border width (bw), the reference point will be
placed at:
		</para>
	  <informaltable>
	    <tgroup cols="3">
	      <tbody>
		<row>
		  <entry>Gravity:</entry>
		  <entry>ref_x:</entry>
		  <entry>ref_y:</entry>
		</row>
		<row>
		  <entry>StaticGravity</entry>
		  <entry>x</entry>
		  <entry>y</entry>
		</row>
		<row>
		  <entry>NorthWestGravity</entry>
		  <entry>x-bw</entry>
		  <entry>y-bw</entry>
		</row>
		<row>
		  <entry>NorthGravity</entry>
		  <entry>x+(width/2)</entry>
		  <entry>y-bw</entry>
		</row>
		<row>
		  <entry>NorthEastGravity</entry>
		  <entry>x+width+bw</entry>
		  <entry>y-bw</entry>
		</row>
		<row>
		  <entry>EastGravity</entry>
		  <entry>x+width+bw</entry>
		  <entry>y+(height/2)</entry>
		</row>
		<row>
		  <entry>SouthEastGravity</entry>
		  <entry>x+width+bw</entry>
		  <entry>y+height+bw</entry>
		</row>
		<row>
		  <entry>SouthGravity</entry>
		  <entry>x+(width/2)</entry>
		  <entry>y+height+bw</entry>
		</row>
		<row>
		  <entry>SouthWestGravity</entry>
		  <entry>x-bw</entry>
		  <entry>y+height+bw</entry>
		</row>
		<row>
		  <entry>WestGravity</entry>
		  <entry>x-bw</entry>
		  <entry>y+(height/2)</entry>
		</row>
		<row>
		  <entry>CenterGravity</entry>
		  <entry>x+(width/2)</entry>
		  <entry>y+(height/2)</entry>
		</row>
	      </tbody>
	    </tgroup>
	    <!-- one of (tgroup graphic) -->
	  </informaltable>
	<para>
The Window manager will use the reference point as calculated above,
until next XMoveWindow request. The Window Manager will place frame decorations
in the following position, based on the window gravity :
		</para>
		<para>
StaticGravity:
		</para>
		<para>
window's left top corner will be placed at (ref_x,ref_y)
		</para>
		<para>
NorthWestGravity:
		</para>
		<para>
window frame's left top corner will be placed at (ref_x,ref_y)
		</para>
		<para>
NorthGravity:
		</para>
		<para>
window frame's top side's center will be placed at (ref_x,ref_y)
		</para>
		<para>
NorthEastGravity:
		</para>
		<para>
window frame's right top corner will be placed at (ref_x,ref_y)
		</para>
		<para>
EastGravity:
		</para>
		<para>
window frame's right side's center will be placed at (ref_x,ref_y)
		</para>
		<para>
SouthWestGravity:
		</para>
		<para>
window frame's left bottom corner will be placed at (ref_x,ref_y)
		</para>
		<para>
SouthGravity:
		</para>
		<para>
window frame's bottom side's center will be placed at (ref_x,ref_y)
		</para>
		<para>
SouthEastGravity:
		</para>
		<para>
window frame's right bottom corner will be placed at (ref_x,ref_y)
		</para>
		<para>
WestGravity:
		</para>
		<para>
window frame's left side's center will be placed at (ref_x,ref_y)
		</para>
		<para>
CenterGravity:
		</para>
		<para>
window frame's center will be placed at (ref_x,ref_y)
		</para>
		</listitem>
		<listitem><para>
Implementation Note for Application developers:
		</para>
		<para>
When client window is resized - its reference point does not move.
So for example if window has SouthEastGravity and it is resized -
the bottom-right corner of its frame will not move but instead
top-left corner will be adjusted by the difference in size.
		</para></listitem>
		<listitem><para>
Implementation Note for WM developers :
		</para>
		<para>
when calculating reference point at the time of initial placement -
initial window's width should be taken into consideration, as if it
was the frame for this window.
		</para></listitem>
	</itemizedlist>
	<para>
[1] ICCCM Version 2.0, &sect;4.1.2.3 and &sect;4.1.5
	</para>
	<para>
[2] ICCCM Version 2.0, &sect;4.2.3
	</para>
	</sect2>
	<sect2>
	<title>Window-in-Window MDI</title>
	<para>
	The authors of this specification acknowledge that there is no standard method to allow the Window Manager to manage windows that are part of a Window-in-Window MDI application.  Application authors are advised to use some other form of MDI, or to propose a mechanism to be included in the next revision of this specification.
	</para>
	</sect2>
	<sect2 id="KILLINGWINDOWS">
		<title>Killing Hung Processes</title>
		<para>
If processes fail to respond to the _NET_WM_PING protocol _NET_WM_PID may be
used in combination with the ICCCM specified WM_CLIENT_MACHINE to 
attempt to kill a process.
		</para>

		<para>
WM_CLIENT_MACHINE must be set to the fully-qualified domain name of the client's
host. This would normally be retrieved using gethostname(2).  When gethostname()
is not available on the client's platform implementors may use the value of the
nodename field of struct utsname as returned by uname(2).  An example of how to
retrieve a value for WM_CLIENT_MACHINE:
		</para>
		<para>
	<programlisting><![CDATA[
int net_get_hostname (char *buf, size_t maxlen)
{
#ifdef HAVE_GETHOSTNAME
	if (buf == NULL) return 0;

	gethostname (buf, maxlen);
	buf [maxlen - 1] = '\0';

	return strlen(buf);
#else
	struct utsname name;
	size_t len;

	if (buf == NULL) return 0;

	uname (&name);
	len = strlen (name.nodename);

	if (len >= maxlen) len = maxlen - 1;
	strncpy (buf, name.nodename, len);
	buf[len] = '\0';

	return len;
#endif
}
]]></programlisting>
		</para>
	</sect2>
	</Sect1>
  <Sect1>
    <title>References</title>
    <para>
[1] F. Yergeau,"UTF-8, a transformation format of ISO 10646", RFC 2279
    </para>
    <para>
[2] David Rosenthal / Stuart W. Marks "Inter-Client Communication Conventions
      Manual (Version 2.0)", X Consortium Standard, X Version 11, Release 6.3 
    </para>
  </Sect1>
  <Sect1>
    <title>Copyright</title>
    <para>
Copyright (C) 2000 See Contributors List
    </para>
    <para> 
Permission  is hereby granted, free of charge, to any person
obtaining a copy of this software and associated  documentation 
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons  to  whom
the Software is furnished to do so, subject to the following
conditions:
    </para>
    <para> 
The above copyright notice and this permission notice  shall
be  included  in  all  copies or substantial portions of the
Software.
    </para>
    <para>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT  WARRANTY  OF  ANY
KIND,  EXPRESS  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE
AND  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS
BE LIABLE FOR ANY CLAIM, DAMAGES  OR  OTHER  LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR  THE  USE
OR OTHER DEALINGS IN THE SOFTWARE.  
    </para>
  </Sect1>
  <Sect1>
	<title>Contributors</title>
	
		<para>Sasha Vasko</para>
		<para>Bradley T. Hughes</para>
		<para>Dominik Vogt</para>
		<para>Havoc Pennington</para>
		<para>Jeff Raven</para>
		<para>Jim Gettys</para>
		<para>John Harper</para>
		<para>Julian Adams</para>
		<para>Matthias Ettrich</para>
		<para>Micheal Rogers</para>
		<para>Nathan Clemons</para>
		<para>Tim Janik</para>
		<para>Tomi Ollila</para>
		<para>Sam Lantinga</para>
		<para>The Rasterman</para>
		<para>Paul Warren</para>
		<para>Owen Taylor</para>
		<para>Marko Macek</para>
		<para>Greg Badros</para>
		<para>Matthias Clasen</para>
		<para>David Rosenthal</para>
		
	</sect1>
  <Sect1>
    <title>Change history</title>
 	    <sect2>
 		<title>Changes since 1.1</title>
 		<itemizedlist>
 			<listitem><para>
 Changed WM_CLIENT_NAME(STRING) from suggested to required for _NET_WM_PID.
 			</para></listitem>
 			<listitem><para>
 Specification and sample code for the content of WM_CLIENT_NAME(STRING).
 			</para></listitem>
 			<listitem><para>
 Added _NET_WM_WINDOW_TYPE_SPLASH, _NET_WM_WINDOW_TYPE_UTILITY.
 			</para></listitem>
 			<listitem><para>
 Added _NET_WM_STATE_FULLSCREEN.
 			</para></listitem>
 			<listitem><para>
 Added _NET_WM_ALLOWED_ACTIONS.
 			</para></listitem>
 	</itemizedlist>
 	</sect2>
    <sect2>
		<title>Changes since 1.0</title>
		<itemizedlist>
			<listitem><para>
Fix doctype, add author info, update data.
			</para></listitem>
			<listitem><para>
Change specification description wording to be more inclusive, and to reflect the joint nature of the specification.
			</para></listitem>
			<listitem><para>
Fix miscellaneous typographical, grammar and spelling errors.
			</para></listitem>
			<listitem><para>
Clarified _NET_SUPPORTED to include ALL atoms, not just the property names.
			</para></listitem>
			<listitem><para>
Various corrections to use of MUST and SHOULD.
			</para></listitem>
			<listitem><para>
Fix problem in _NET_WM_ICON where 'bytes' should have been 'cardinals'
			</para></listitem>
			<listitem><para>
Replaced ISO-8559-1 characters with entities.
			</para></listitem>
	</itemizedlist>
	</sect2>
    <sect2>
		<title>Changes since 1.0pre5</title>
		<itemizedlist>
			<listitem><para>
Change history moved to end.
			</para></listitem>
			<listitem><para>
UTF-8 Reference updated.
			</para></listitem>
			<listitem><para>
Window Gravity information updated.
			</para></listitem>
			<listitem><para>
Copyright Added.
			</para></listitem>
			<listitem><para>
Minor typo corrections.
			</para></listitem>
	</itemizedlist>
	</sect2>
	<sect2>
		<title>Changes since 1.0pre4</title>
		<itemizedlist>
			<listitem><para>
Clarified the interpretation of client-provided geometries on large desktops.
			</para></listitem>
			<listitem><para>
Added more explanation for _NET_DESKTOP_NAMES. 
			</para></listitem>
			<listitem><para>
Added _NET_WM_ICON_NAME and _NET_WM_VISIBLE_ICON_NAME.
			</para></listitem>
			<listitem><para>
Tried to improve the wording of _NET_WM_STRUT explanation.
			</para></listitem>
			<listitem><para>
Changed _NET_WORKAREA to an array of viewport-relative geometries.
			</para></listitem>
			<listitem><para>
Updated list of <quote>dependent</quote> properties for _NET_NUMBER_OF_DESKTOPS
to include _NET_WORKAREA and _NET_DESKTOP_VIEWPORT.
			</para></listitem>
			<listitem><para>
Tidied formatting of all client messages.
			</para></listitem>
		</itemizedlist>
	</sect2>
	<sect2>
		<title>Changes since 1.0pre3</title>
		<itemizedlist>
			<listitem><para>
Added information about common non-ICCCM features.
			</para></listitem>
			<listitem><para>
Added explanation of sending messages to the root window.
			</para></listitem>
			<listitem><para>
Removed XA_ prefix from type names.
			</para></listitem>
			<listitem><para>
Clarified that <quote>mapping order</quote> refers to inital mapping 
and specify the directions of both orders.
			</para></listitem>
			<listitem><para>
Clarified that desktops have a common size specified by _NET_DESKTOP_GEOMETRY.
			</para></listitem>
			<listitem><para>
Rewrote explanation of _NET_DESKTOP_VIEWPORT.
			</para></listitem>
			<listitem><para>
Tidied formatting of _NET_CURRENT_DESKTOP.
			</para></listitem>
			<listitem><para>
Replaced <quote>window handle</quote> by <quote>window ID</quote>.
			</para></listitem>
			<listitem><para>
Tidied formatting of _NET_WORKAREA.
			</para></listitem>
			<listitem><para>
Rewrote the motivation for _NET_VIRTUAL_ROOTS.
			</para></listitem>
			<listitem><para>
Added advice on Pointer grabs to _NET_WM_MOVERESIZE.
			</para></listitem>
			<listitem><para>
Fixed typos in _NET_WM_STATE.
			</para></listitem>
			<listitem><para>
Added _NET_WM_STATE_SKIP_PAGER.
			</para></listitem>
			<listitem><para>
Tidied formatting of _NET_WM_STRUT.
			</para></listitem>
			<listitem><para>
Tidied formatting of _NET_WM_ICON_GEOMETRY.
			</para></listitem>
		</itemizedlist>
	</sect2>		
	<sect2>
		<title>Changes since 1.0pre2</title>
		<itemizedlist>
			<listitem><para>
_NET_SET_NUMBER_OF_DESKTOPS -> _NET_NUMBER_OF_DESKTOPS for consistency.
			</para></listitem>
			<listitem><para>
_NET_WM_VISIBLE_NAME_STRING -> _NET_WM_VISIBLE_NAME for consistency.
			</para></listitem>
			<listitem><para>
_NET_WM_STATE: added explanation of permitted extensions. Added explanation of 
being set / not set.
			</para></listitem>
			<listitem><para>
Spellchecked, corrected various typos.
			</para></listitem>
			<listitem><para>
UTF8 -> UTF-8 for consistency.
			</para></listitem>
			<listitem><para>
added references to the ICCCM an UTF-8 (incomplete).
			</para></listitem>
			<listitem><para>
added data and event formats where missing.
			</para></listitem>
			<listitem><para>
clarified _NET_SUPPORTING_WM_CHECK.
			</para></listitem>
			<listitem><para>
fixed formatting of _NET_CLOSE_WINDOW message.
			</para></listitem>
		</itemizedlist>
	</sect2>		
	<sect2>
		<title>Changes since 1.0pre1</title>
		<itemizedlist>
			<listitem><para>
Removed implementation note concerning Gnome's (potential) file manager behaviour.
			</para></listitem>
			<listitem><para>
The Window Movement section of the implementation notes has been revised.
			</para></listitem>
		</itemizedlist>
	</sect2>		
	<sect2>
		<title>Changes since 1.9f</title>
		<itemizedlist>
			<listitem><para>
Revised revision number for first accepted release 1.9XX -> 1.0preXX.
			</para></listitem>
			<listitem><para>
Prerequisites for adoption of this specification added.
			</para></listitem>
			<listitem><para>
Tidied formatting of _NET_CURRENT_DESKTOP for consistency.
			</para></listitem>
			<listitem><para>
Tidied formatting of _NET_ACTIVE_WINDOW  for consistency. Removed doubled text.
			</para></listitem>
			<listitem><para>
Tidied formatting of _NET_WM_DESKTOP for consistency.
			</para></listitem>
			<listitem><para>
Killing Hung Processes implementation note added. _NET_WM_PID and _NET_WM_PING now link to this.
			</para></listitem>
			<listitem><para>
Clarified x_root and y_root meaning for _NET_WM_MOVERESIZE.
			</para></listitem>
			<listitem><para>
Added contributor list.
			</para></listitem>
		</itemizedlist>
	</sect2>		
	<sect2>
		<title>Changes since 1.9e</title>
		<itemizedlist>
			<listitem><para>
Added _NET_WM_VISIBLE_NAME_STRING
			</para></listitem>
			<listitem><para>
Removed ambiguity from _NET_NUMBER_OF_DESKTOPS and  _NET_DESKTOP_NAMES in combination.
			</para></listitem>
			<listitem><para>
Set _NET_WM_MOVERESIZE format to 32 for consistency.
			</para></listitem>
			<listitem><para>
Removed _NET_PROPERTIES.
			</para></listitem>
			<listitem><para>
Removed comment from _NET_WM_MOVERESIZE.
			</para></listitem>
		</itemizedlist>
	</sect2>		
	<sect2>
		<title>Changes since 1.9d</title>
		<itemizedlist>
			<listitem><para>
Added _NET_VIRTUAL_ROOTS
			</para></listitem>
			<listitem><para>
Added note about ICCCM compliant window moves.
			</para></listitem>
			<listitem><para>
Added _NET_WM_HANDLED_ICONS
			</para></listitem>
			<listitem><para>
Added _NET_SUPPORTING_WM_CHECK
			</para></listitem>
			<listitem><para>
Removed degrees of activation
			</para></listitem>
		</itemizedlist>
	</sect2>		
		<sect2>
		<title>Changes since 1.9c</title>
		<itemizedlist>
			<listitem>
				<para>
Removed packaging of hints into 2 X properties.  Jim Gettys points out that the
performance gains of fewer round trips can be better achieved using Xlib
routines.
				</para>
			</listitem>
			<listitem>
				<para>
Clarified that _NET_DESKTOP_VIEWPORT is in pixels
				</para>
			</listitem>
			<listitem>
				<para>
_NET_DESKTOP_VIEWPORT is now an array, one for each desktop, to allow for
different active viewports on different desktops
				</para>
			</listitem>
			<listitem>
				<para>
_NET_WM_STRUT now only applies on desktops on which the client is visible
				</para>
			</listitem>
			<listitem>
				<para>
Introduced RFC 2119 language, and attempted to clarify the roles of the Window
Manager, Pagers and Applications
				</para>
			</listitem>
			<listitem>
				<para>
Added _NET_WM_NAME
				</para>
			</listitem>
			<listitem>
				<para>
_NET_DESKTOP_NAMES now in UTF8
				</para>
			</listitem>
			<listitem>
				<para>
Desktops now start from 0
				</para>
			</listitem>
			<listitem>
				<para>
Added _NET_WM_PID
				</para>
			</listitem>
			<listitem>
				<para>
Added _NET_WM_PING protocol
				</para>
			</listitem>
			<listitem>
				<para>
Added _NET_WM_STATE_SKIP_TASKBAR
				</para>
			</listitem>
		</itemizedlist>
	</sect2>
	
	<sect2>
	<title>Changes since 1.9b</title>
	<itemizedlist>
	<listitem><para>Removed _NET_NUMBER_OF_DESKTOPS client message, as it overlaps unnecessarily with _NET_{INSERT/DELETE}_DESKTOP.</para>
	</listitem>
	<listitem><para>Replaced _NET_WM_LAYER and _NET_WM_HINTS with _NET_WM_WINDOW_TYPE functional hint.</para></listitem>
	<listitem><para>Changed _NET_WM_STATE to a list of atoms, for extensibility.</para></listitem>
	<listitem><para>Expanded description of _NET_WORKAREA and _NET_WM_STRUT.</para></listitem>
	<listitem><para>Removed _NET_WM_SIZEMOVE_NOTIFY protocol. </para></listitem>
	<listitem><para>Added degrees of activation to _NET_ACTIVE_WINDOW client message</para></listitem>
	<listitem><para>Added _NET_WM_ICON</para></listitem>
	<listitem><para>My comments are in [[ ]].  Comments from Marko's draft are in [[MM: ]]</para></listitem>
	</itemizedlist>
    </sect2>
  </sect1>
</article>

