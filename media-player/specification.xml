<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

<!-- XML file was created by LyX 1.6.4
  See http://www.lyx.org/ for more information -->
<article lang="en_US">
<articleinfo>
<title>Free Media Player Specifications</title>
<date>10/14/2009</date><author>
<firstname>Jeff</firstname><surname>Mitchell</surname></author><abstract>
<para>This specification describes various metadata and behavioral items intended to reduce complexity and enhance functionality for users of free music and media players. It does this by proposing standards for common functionality needs where none currently exist, and doing so in a way that is easily adoptable cross-player and cross-format, when applicable.</para>
</abstract></articleinfo><sect1>
<title>Metadata Tags</title>
<para>The metadata tag ideas evolved from Quod Libet's VorbisComments suggestions at <url>http://code.google.com/p/quodlibet/wiki/Specs_VorbisComments</url>, however this attempts to not only address ambiguities and incompatibilities with the specification at that URL, but also to define how this functionality should be applied cross-format. It is intended that as usable ways of inserting the metadata described become available for formats not currently specified, that this document will be updated to meet those needs.</para>
<para>All newly-specified tags carry an identifier &ldquo;FMPS_&rdquo; to tie the tags to this specification. The reason is simple. Since the official metadata specifications either fail to define or define unusable tags, these value are only official to the extent that this specification is adopted. Without an identifier to give context to the meanings and limitations of the values, there can be no certainty that a noncompliant media player will use the same tag names in an incompatible fashion, whether intentionally or not, nor any way to determine whether a seemingly compatible use of the tags by a noncompliant player actually results in user-intended behavior. As these identifiers are read and modified only by players and advanced users, it is not expected to be a hindrance to adoption or to cause undue burden on either.</para><sect2>
<title>Song Rating Tags</title>
<para>Most media players support the notion of rating content, however standards for storing ratings in files do not exist. Some file metadata formats completely lack rating fields; others require personal information to be used as an identifier (such as a user's email address) or an organizational identifier (which reduces cross-player compatibility). The goal therefore is simple: to avoid any personal identifying information but avoid tying the rating to a specific player.</para>
<para>There are benefits to both integers and floating point values for ratings. Users are more naturally able to understand integer ratings; float values are useful in many algorithmic rating situations. Therefore, both are defined in this specification. It is expected that any user-defined rating value is stored in the integer rating tag, with the floating-point tag reserved for automatic rating algorithms and special-purpose needs. As a result, while all players should implement the integer rating tag, only players needing or able to use such functionality need implement the float rating tag.</para>
<para>If both tags exist when a file is being imported or read into a player's library, the integer rating takes precedence.</para>
<para>For all tag formats, the following is defined for both integer and float ratings:</para><itemizedlist>
<listitem><para>All identifers and values are strings in UTF-8 encoding.</para></listitem><listitem><para>A file that has no such tag is to be considered unrated for that purpose (user or algorithm). Removing ratings from a track in the media player should cause the rating tag to be removed as well.</para></listitem><listitem><para>The identifier for the integer rating is &ldquo;FMPS_Rating&rdquo;. The identifier for the float rating is &ldquo;FMPS_FloatRating&rdquo;.</para></listitem></itemizedlist><para>For all tag formats, the following is defined for the integer rating:</para><itemizedlist>
<listitem><para>Ratings are integers between 0 and 100, inclusive. Zero is the lowest possible rating; 100 is the highest possible rating.</para></listitem><listitem><para>The 0-100 value range should be mapped appropriately into the application. For instance, for an application that allows one to five stars, with no stars for unrated tracks, one star corresponds to 20, three stars to 60, and so on. Unrated tracks would simply remove the tag, and would not set a value of zero.</para></listitem></itemizedlist><para>For all tag formats, the following is defined for the float rating:</para><itemizedlist>
<listitem><para>Ratings are a float value between 0.0 and 1.0, inclusive. 0.0 is the lowest possible rating; 1.0 is the highest possible rating.</para></listitem><listitem><para>Float values should be limited to six decimal places.</para></listitem></itemizedlist><sect3>
<title>MP3</title>
<para>MP3 ratings should be stored in a TXXX frame with the Description set to the specified identifier and the Text set to the string value of the float rating.</para></sect3><sect3>
<title>VorbisComments</title>
<para>Any file supporting VorbisComments (Vorbis, FLAC, Theora, Speex) should use the specified identifier as the Key and the string value of the float rating as the Value.</para></sect3></sect2><sect2>
<title>Playcount Tags</title>
<para>As with ratings, there are benefits to both integer and floating point playcount tags. While a user can easily understand the notion of an integer-based playcount of a file, interesting data can be displayed to the user by keeping track of how much of a file a user consumes each time it is played, in order to give precise calculations of data such as exact amount of time spent listening to a file. Therefore, like ratings, both integer and float values are defined.</para>
<para>If both tags exist when a file is being imported or read into a player's library, the integer playcount takes precedence.</para>
<para>For all tag formats, the following is defined for both integer and float playcounts:</para><itemizedlist>
<listitem><para>All identifers and values are strings in UTF-8 encoding.</para></listitem><listitem><para>A file that has no such tag is to be considered unplayed for that purpose (user or algorithm). Removing playcount information from a track in the media player should cause the playcount tag to be removed as well.</para></listitem><listitem><para>The identifier for the integer rating is &ldquo;FMPS_Playcount&rdquo;. The identifier for the float rating is &ldquo;FMPS_FloatPlaycount&rdquo;.</para></listitem></itemizedlist><para>For all tag formats, the following is defined for the integer playcount:</para><itemizedlist>
<listitem><para>The miminum value is zero, where zero is an acceptable value but indicates that a track has not been played (the same as if the track had no integer playcount tag).</para></listitem><listitem><para>The maximum value is the largest value able to be stored in a 32-bit unsigned integer, uint32_t: 4,294,967,295.</para></listitem></itemizedlist><para>For all tag formats, the following is defined for the float playcount:</para><itemizedlist>
<listitem><para>Playcounts are a float value with a minimum of 0.0, where 0.0 is an acceptable value but indicates that a track has not been played (the same as if the track had no float playcount tag).</para></listitem><listitem><para>Float values should be limited to six decimal places.</para></listitem><listitem><para>The maximum value is 0.000001 less than the largest value able to be stored in a 32-bit unsigned integer: 4,294,967,294.999999. This is so that the float playcount value can be rounded to an integer equivalent, if necessary.</para></listitem></itemizedlist><sect3>
<title>MP3</title>
<para>MP3 playcounts should be stored in a TXXX frame with the Description set to the specified identifier and the Text set to the string value of the integer playcount.</para></sect3><sect3>
<title>VorbisComments</title>
<para>Any file supporting VorbisComments (Vorbis, FLAC, Theora, Speex) should use the specified identifier as the Key and the string value of the float playcount as the Value.</para></sect3></sect2><sect2>
<title>Performer Roles</title>
<para>Performer roles allow you to describe the performers in a track. Current support for these roles in tag formats is sporadic or difficult to parse. As many of these tags as desired can be specified, to include all relevant performer information.</para>
<para>For all tag formats, the following is defined:</para><itemizedlist>
<listitem><para>All identifiers and values are of strings in UTF-8 encoding.</para></listitem><listitem><para>The identifier used is &ldquo;FMPS_Performer:X&rdquo;, where X is the user-defined role (&ldquo;Guitar&rdquo;, &ldquo;Guitar (Backup)&rdquo;, &ldquo;Vocals&rdquo;).</para></listitem><listitem><para>The value of each identifier is the role performer's name.</para></listitem></itemizedlist><sect3>
<title>MP3</title>
<para>MP3 performer role information should be stored in a TXXX frame with the Description set to the specified identifier/role and the Text set to the role performer.</para></sect3><sect3>
<title>VorbisComments</title>
<para>Any file supporting VorbisComments (Vorbis, FLAC, Theora, Speex) should use the specified identifier/role as the Key and the role performer as the Value.</para></sect3></sect2></sect1><sect1>
<title>Filesystem Directives</title>
<para>Common functionality for many media players is the notion of a library or collection as a store of media objects that can be played. Generally, users specify or drag-n-drop directories or files that they wish to have added to this store. These subsections contain files that can be present on a user's filesystem to allow for more fine-grained control over import.</para><sect2>
<title>Ignore Directive</title>
<para>When a directory is being parsed, it should first be checked for a file with the name &ldquo;fmps_ignore&rdquo;. If present and empty, the parser should recursively ignore that directory's files and subdirectories, if recursive parsing was already enabled. If the file is not empty, it may contain control statements, one statement per line, in UTF-8 encoding, as described in the following subsubsections.</para><sect3>
<title>nonrecursive</title>
<para>If the file contains a line with the text &ldquo;nonrecursive&rdquo;, the parser should interpret this to mean that the current directory's files should be ignored but that it should still scan subdirectories, if recusive parsing was already enabled.</para></sect3></sect2></sect1></article>